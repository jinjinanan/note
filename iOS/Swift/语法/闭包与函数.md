
[函数](#1)
[闭包](#2)

<h1 id='1'>函数</h1>

#### 函数的参数和返回值

###### 返回元组

```Swift
func minMax(array: [Int]) -> (min: Int, max: Int) {
     var currentMin = array[0]
     var currentMax = array[0]
     for value in array[1..<array.count] {
         if value < currentMin {
             currentMin = value
         } else if value > currentMax {
             currentMax = value
	} }
    return (currentMin, currentMax)
}
let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) 
print("min is \(bounds.min) and max is \(bounds.max)")
```

###### 返回可选的元组

```Swift
func minMax(array: [Int]) -> (min: Int, max: Int)? {
	...
}
```

#### 函数的参数标签和参数名称

###### 指定参数标签

```Swift
func someFunction(argumentLabel parameterName: Int) 
{
// 在函数体内，parameterName 代表参数值
}
```

###### 忽略参数标签

```Swift
func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值
}
```

###### 默认参数值

```Swift
func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。
 }
```

###### 可变参数

```Swift
func arithmeticMean(_ numbers: Double...) -> Double {
     var total: Double = 0
     for number in numbers {
         total += number
     }
     return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// 返回 3.0, 是这 5 个数的平均数。 arithmeticMean(3, 8.25, 18.75)
// 返回 10.0, 是这 3 个数的平均数。
```

###### 输入输出参数

**输入输出参数不能有默认值，而且可变参数不能用`inout`标记。**

```Swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {

}

var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
```

#### 函数类型  

**函数的类型由函数的参数类型和返回类型组成**  

例1
```Swift
func addTwoInts(_ a: Int, _ b: Int) -> Int 
{
}
(Int, Int) -> Int
```

例2

```Swift
func printHelloWorld() 
{
}
() -> Void 
```

###### 使用函数类型  

**使用函数类型就像使用其他类型一样**  

`var mathFunction: (Int, Int) -> Int = addTwoInts`

###### 函数类型作为参数类型

```Swift
func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
     print("Result: \(mathFunction(a, b))")
}
```

###### 函数类型作为返回类型

```Swift
func stepForward(_ input: Int) -> Int {
     return input + 1
 }
func stepBackward(_ input: Int) -> Int {
     return input - 1
}
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
     return backward ? stepBackward : stepForward
}
```

#### 嵌套函数

---

<h2 id="2">闭包</h2>

• 全局函数是一个有名字但不会捕获任何值的闭包  
• 嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包  
• 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包  

### 语法

```Swift
{ (parameters) -> returnType in
     statements
}
```

```
{ s1, s2 in s1 > s2 }
```

#### 尾随闭包  

```Swift
func someFunctionThatTakesAClosure(closure: () -> Void) { // 函数体部分
}

// 以下是不使用尾随闭包进行函数调用 
someFunctionThatTakesAClosure(closure: {
// 闭包主体部分 })

// 以下是使用尾随闭包进行函数调用 
someFunctionThatTakesAClosure() {
// 闭包主体部分 }
```

#### 值捕获

#### 闭包是引用类型

函数和闭包都是引用类型

#### 逃逸闭包

当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行 `@escaping`

```Swift
var completionHandlers: [() -> Void] = []

//声明
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
func someFunctionWithNonescapingClosure(closure: () -> Void) {
    closure()
}

//类
class SomeClass {
var x = 10
     func doSomething() {
         someFunctionWithEscapingClosure { self.x = 100 }
         someFunctionWithNonescapingClosure { x = 200 }
     }
}

// 执行函数时候，仅执行一般闭包，不会调用逃逸闭包， 逃逸闭包需手动执行 
let instance = SomeClass() instance.doSomething() print(instance.x)
// 打印出 "200"

completionHandlers.first?() print(instance.x)
// 打印出 "100"

```

#### 自动闭包

[闭包](http://www.cocoachina.com/ios/20161225/18412.html)